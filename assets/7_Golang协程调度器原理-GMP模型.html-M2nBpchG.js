import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as o,o as p}from"./app-H5WDZ675.js";const a={};function g(r,t){return p(),n("div",null,t[0]||(t[0]=[o("h1",{id:"golang协程调度器原理-gmp模型",tabindex:"-1"},[o("a",{class:"header-anchor",href:"#golang协程调度器原理-gmp模型"},[o("span",null,"Golang协程调度器原理 GMP模型")])],-1),o("p",null,"g 是指 go 协程，m 指 操作系统的工作线程，p 代表协程的调度器。 GMP 的调度思想主要是指 p 怎么高效的让 m 执行 g。",-1),o("p",null,"一般一个 p 对应一个 m，p 一直取队列的协程给线程去执行， p 有一个保存待执行的 go 本地队列，全局也有一个 go 队列， 当 p 从本地和全局队列取不到协程时会发生工作窃取的情况，即从其他 p 中取数据。",-1),o("p",null,"当 G 发生系统调用时，p 会解绑发生系统调用的线程，找空闲的 m 处理协程",-1),o("p",null,"基本知识点 G：go 协程 M：操作系统的工作线程 P：go 协程的调度器 全局G队列：存放的也是等待运行的G，当P的本地队列为空时，优先从全局队列获取 P的本地队列：存放的也是等待运行的G，不超过256个，如果队列满了，则会把本地队列中一半的G移动到全局队列",-1),o("p",null,"调度器的设计策略 复用线程：避免频繁的创建、销毁线程 工作窃取（work stealing 机制）：当本线程无可运行的G时，尝试从其他线程绑定的P偷取G，而不是销毁线程 系统调用 hand off 机制：G进行系统调用阻塞时，线程释放绑定的 P，把 P 转移给其他空闲的线程执行 设置P的数量，提高并行能力 抢占式调度 1.14 前有局限性，在函数调用中时检查的是否需要抢占 （一个goroutine最多占用 CPU 10 ms） 调度器每调度 61 次的时候，都会尝试从全局队列里取出待运行的 goroutine 来运行",-1)]))}const i=e(a,[["render",g],["__file","7_Golang协程调度器原理-GMP模型.html.vue"]]),c=JSON.parse('{"path":"/notebook/go/2_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8E%9F%E7%90%86/7_Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86-GMP%E6%A8%A1%E5%9E%8B.html","title":"Golang协程调度器原理 GMP模型","lang":"zh-CN","frontmatter":{"description":"Golang协程调度器原理 GMP模型 g 是指 go 协程，m 指 操作系统的工作线程，p 代表协程的调度器。 GMP 的调度思想主要是指 p 怎么高效的让 m 执行 g。 一般一个 p 对应一个 m，p 一直取队列的协程给线程去执行， p 有一个保存待执行的 go 本地队列，全局也有一个 go 队列， 当 p 从本地和全局队列取不到协程时会发生工作...","head":[["meta",{"property":"og:url","content":"https://zmf96.github.io/notebook/go/2_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8E%9F%E7%90%86/7_Golang%E5%8D%8F%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8%E5%8E%9F%E7%90%86-GMP%E6%A8%A1%E5%9E%8B.html"}],["meta",{"property":"og:site_name","content":"小明的笔记本"}],["meta",{"property":"og:title","content":"Golang协程调度器原理 GMP模型"}],["meta",{"property":"og:description","content":"Golang协程调度器原理 GMP模型 g 是指 go 协程，m 指 操作系统的工作线程，p 代表协程的调度器。 GMP 的调度思想主要是指 p 怎么高效的让 m 执行 g。 一般一个 p 对应一个 m，p 一直取队列的协程给线程去执行， p 有一个保存待执行的 go 本地队列，全局也有一个 go 队列， 当 p 从本地和全局队列取不到协程时会发生工作..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-02T04:05:12.000Z"}],["meta",{"property":"article:author","content":"XiaoMing"}],["meta",{"property":"article:modified_time","content":"2024-08-02T04:05:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"Golang协程调度器原理 GMP模型\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-02T04:05:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoMing\\",\\"url\\":\\"https://github.com/zmf963\\"}]}"]]},"headers":[],"git":{"createdTime":1722571512000,"updatedTime":1722571512000,"contributors":[{"name":"one","email":"one@one.com","commits":1}]},"readingTime":{"minutes":1.55,"words":465},"filePathRelative":"notebook/go/2_高级特性-原理/7_Golang协程调度器原理-GMP模型.md","localizedDate":"2024年8月2日","excerpt":"\\n<p>g 是指 go 协程，m 指 操作系统的工作线程，p 代表协程的调度器。\\nGMP 的调度思想主要是指 p 怎么高效的让 m 执行 g。</p>\\n<p>一般一个 p 对应一个 m，p 一直取队列的协程给线程去执行，\\np 有一个保存待执行的 go 本地队列，全局也有一个 go 队列，\\n当 p 从本地和全局队列取不到协程时会发生工作窃取的情况，即从其他 p 中取数据。</p>\\n<p>当 G 发生系统调用时，p 会解绑发生系统调用的线程，找空闲的 m 处理协程</p>\\n<p>基本知识点\\nG：go 协程\\nM：操作系统的工作线程\\nP：go 协程的调度器\\n全局G队列：存放的也是等待运行的G，当P的本地队列为空时，优先从全局队列获取\\nP的本地队列：存放的也是等待运行的G，不超过256个，如果队列满了，则会把本地队列中一半的G移动到全局队列</p>","autoDesc":true}');export{i as comp,c as data};
