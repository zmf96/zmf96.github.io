import{_ as o}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,a as t,o as r}from"./app-H5WDZ675.js";const a={};function c(p,e){return r(),n("div",null,e[0]||(e[0]=[t("h1",{id:"gc-垃圾回收",tabindex:"-1"},[t("a",{class:"header-anchor",href:"#gc-垃圾回收"},[t("span",null,"GC 垃圾回收")])],-1),t("p",null,"从 root 节点开始，使用广度优先算法遍历对象，把遍历到的对象标记为灰色， 之后再使用广度优先算法遍历灰色节点的子节点，并把之前的灰色变成黑色， 然后一直重复遍历灰色结点的逻辑，直到没有灰色结点。 插入屏障和删除屏障",-1),t("p",null,"标记清除算法",-1),t("p",null,"三色并发标记算法（白色 垃圾、灰色 检查态、黑色 有用） 插入屏障（仅对堆上的数据有效） 插入数据时把数据置为灰色 需要 STW 扫描栈上数据 插入写屏障不对栈生效，需要执行下 STW 的三色标记法（需要 STW 花费时间） 删除屏障 删除了会先变成灰色，下一个周期表成垃圾（回收精度低） 内存回收的触发时间 内存分配量达到阀值触发 gc（每当内存扩大一倍时触发 gc） 定期触发 gc（最长 2 分钟触发 gc） 执行函数触发 gc Gc 性能优化 对象数量越多 GC 压力越大（对象复用，或者大对象组合小对象） 内存逃逸也会增大 GC 压力 参数传递指针也会增加 GC 的压力，不要盲目传递指针",-1),t("p",null,"Root set根节点就是发现堆内存可达数据的一组起点，一般为bss段、数据段以及协程栈对应的元数据",-1)]))}const l=o(a,[["render",c],["__file","8_GC-垃圾回收.html.vue"]]),s=JSON.parse('{"path":"/notebook/go/2_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8E%9F%E7%90%86/8_GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html","title":"GC 垃圾回收","lang":"zh-CN","frontmatter":{"description":"GC 垃圾回收 从 root 节点开始，使用广度优先算法遍历对象，把遍历到的对象标记为灰色， 之后再使用广度优先算法遍历灰色节点的子节点，并把之前的灰色变成黑色， 然后一直重复遍历灰色结点的逻辑，直到没有灰色结点。 插入屏障和删除屏障 标记清除算法 三色并发标记算法（白色 垃圾、灰色 检查态、黑色 有用） 插入屏障（仅对堆上的数据有效） 插入数据时把数...","head":[["meta",{"property":"og:url","content":"https://zmf96.github.io/notebook/go/2_%E9%AB%98%E7%BA%A7%E7%89%B9%E6%80%A7-%E5%8E%9F%E7%90%86/8_GC-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"}],["meta",{"property":"og:site_name","content":"小明的笔记本"}],["meta",{"property":"og:title","content":"GC 垃圾回收"}],["meta",{"property":"og:description","content":"GC 垃圾回收 从 root 节点开始，使用广度优先算法遍历对象，把遍历到的对象标记为灰色， 之后再使用广度优先算法遍历灰色节点的子节点，并把之前的灰色变成黑色， 然后一直重复遍历灰色结点的逻辑，直到没有灰色结点。 插入屏障和删除屏障 标记清除算法 三色并发标记算法（白色 垃圾、灰色 检查态、黑色 有用） 插入屏障（仅对堆上的数据有效） 插入数据时把数..."}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2024-08-02T04:05:12.000Z"}],["meta",{"property":"article:author","content":"XiaoMing"}],["meta",{"property":"article:modified_time","content":"2024-08-02T04:05:12.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"GC 垃圾回收\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2024-08-02T04:05:12.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"XiaoMing\\",\\"url\\":\\"https://github.com/zmf963\\"}]}"]]},"headers":[],"git":{"createdTime":1722571512000,"updatedTime":1722571512000,"contributors":[{"name":"one","email":"one@one.com","commits":1}]},"readingTime":{"minutes":1.24,"words":372},"filePathRelative":"notebook/go/2_高级特性-原理/8_GC-垃圾回收.md","localizedDate":"2024年8月2日","excerpt":"\\n<p>从 root 节点开始，使用广度优先算法遍历对象，把遍历到的对象标记为灰色，\\n之后再使用广度优先算法遍历灰色节点的子节点，并把之前的灰色变成黑色，\\n然后一直重复遍历灰色结点的逻辑，直到没有灰色结点。\\n插入屏障和删除屏障</p>\\n<p>标记清除算法</p>\\n<p>三色并发标记算法（白色 垃圾、灰色 检查态、黑色 有用）\\n插入屏障（仅对堆上的数据有效）\\n插入数据时把数据置为灰色\\n需要 STW 扫描栈上数据\\n插入写屏障不对栈生效，需要执行下 STW 的三色标记法（需要 STW 花费时间）\\n删除屏障\\n删除了会先变成灰色，下一个周期表成垃圾（回收精度低）\\n内存回收的触发时间\\n内存分配量达到阀值触发 gc（每当内存扩大一倍时触发 gc）\\n定期触发 gc（最长 2 分钟触发 gc）\\n执行函数触发 gc\\nGc 性能优化\\n对象数量越多 GC 压力越大（对象复用，或者大对象组合小对象）\\n内存逃逸也会增大 GC 压力\\n参数传递指针也会增加 GC 的压力，不要盲目传递指针</p>","autoDesc":true}');export{l as comp,s as data};
